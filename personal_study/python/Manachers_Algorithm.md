# Manacher's Algorithm

## 개요

- 문자열 내에 존재하는 모든 Palindrome(회문)을 *O(N)*에 구하는 알고리즘
  - Palindrome(회문): 길이가 *n*인 문자열 중 *i*번째 문자와 *n-i-1*번째 문자가 같은 문자열



## 원리

- 부분 문자열중에 팰린드롬이 되는 제일 긴 문자열을 찾고, 그 문자열의 중심으로 부터 대칭되는 부분 문자열 역시 팰린드롬이라는 점을 이용
  - 부분 문자열: 주어진 문자열에서 연속되는 맨 앞에서 부터 *k*개, 뒤에서 부터 *l*개(*k+l<n*)를 자른 문자열
- 중심 문자를 기준으로 양쪽을 확인하는 방식이기 때문에 문자열의 길이가 홀수 일 때만 가능
  - 문자열의 길이가 짝수일 경우 양끝과 문자 사이사이에 #을 넣어서 홀수로 변경해 처리
    - ex. banana(길이 6, `p=[0, 0, 1, 2, 1, 0]`이 나와야 하는 알고리즘인데 다른 결과 출력)
    - -> #b#a#n#a#n#a#(길이 13, `p=[0, 0, 0, 0, 0, 3, 5, 3, 0]`)
    - 결과가 사실상 동일한 내용이지만 숫자는 #을 제외한 값으로 조절 필요
    - 다만 회문의 반경이 아니라 회문 전체의 길이가 필요한 경우라면 오히려 맞는 값이 알아서 만들어진 것
- 하나의 부분 문자열이 회문이라는 사실을 확인하면 중심점을 기준으로 양쪽이 대칭이기 때문에 앞에서 이미 확인한 내용을 반영해 다시 확인할 필요 없도록 만들어 효율성 증가

| j    | s    | a                | t    | j                    | t    | a                                                            | s           | c    |
| ---- | ---- | ---------------- | ---- | -------------------- | ---- | ------------------------------------------------------------ | ----------- | ---- |
| i=0  | 1    | 2                | 3    | 4                    | 5    | 6                                                            | 7           | 8    |
| <-   |      | 중심점, p[2] = 2 |      | 끝점, r=4 ->         |      |                                                              |             |      |
|      | <-   |                  |      | 중심점 c=4, p[4] = 3 |      |                                                              | 끝점 r=7 -> |      |
|      |      |                  |      |                      |      | 현재 c=4, i=6, r=7<br>min(p[2×c-i]=2, r-i=1)=1<br>즉 뒤의 한칸(7-6)은 이미 i=2(2×4-6)에서 확인<br>따라서 p[i]를 일단 1로 초기화 시켜 놓고 그 뒤를 확인 |             |      |

- 예시 문자열은 jsatjtasc
- i는 현재 문자의 인덱스, c와 r은 각각 현재 문자가 포함된 회문의 중심점과 끝점의 인덱스
- i=2일 때와 i=6일때의 앞뒤 한칸은 sat와 tas로 사실상 동일(i=4를 기준으로 대칭이기 때문에 방향만 반대)하기 때문에 그만큼은 확인할 필요 없음



## 구현


```python
def manacher(s):									# 입력 문자열
    n = len(s)										# 문자열의 길이 확인
    p = [0] * n										# 현재 위치를 중심으로한 회문의 길이

    r = -1											# 회문의 끝점 인덱스
    c = -1											# 회문의 중심점 인덱스

    for i in range(0, n - 1):
        if r >= i:									# 이전 회문의 끝점을 아직 지나지 않았다면
            p[i] = min(r - i, p[c * 2 - i])			# c를 기준으로 반대편 회문의 길이와 r까지 남은 거리 중 더 짧은 부분 활용

        while i + p[i] + 1 < n:						# 문자열의 길이를 넘어가지 않고
            if s[i + p[i] + 1] == s[i - p[i] - 1]:	# 현재 문자에서 양쪽의 문자가 같은지 확인
                p[i] += 1							# 같다면 길이 + 1
            else:
                break								# 다른 문자가 나오면 반복문 종료

        if i + p[i] > r:							# 끝점을 넘어갔다면
            r = i + p[i]							# 끝점과
            c = i									# 중심점 갱신

    return p										# 문자열의 각 문자들을 중심점으로하는 회문의 길이를 저장한 리스트
```



### 참고

http://www.secmem.org/blog/2019/03/10/Manacher/#
